#include "mesh_model_import_export.h"
#include <QFile>
#include <QDebug>
#include "wrap/io_trimesh/io_mask.h"
#include "mlexception.h"

bool MeshModelImport_Export::open(const QString& formatName, const QString& fileName, CMeshO& cm, vcg::CallBackPos* cb)
{
    QString errorMsgFormat = tr("Error encountered while loading file") + QString(":\n\"%1\"\n\n") + QString("Error details") + QString(": %2");

    if (!QFile::exists(fileName))
    {
        throw MLException(errorMsgFormat.arg(fileName, tr("File does not exist")));
    }
    // initializing progress bar status
    if (cb != NULL)
    {
        (*cb)(0, "Loading...");
    }

    std::string filename = QFile::encodeName(fileName).constData();

    if ((formatName.toUpper() == QString("OBJ")) || (formatName.toUpper() == QString("QOBJ")))
    {
        vcg::tri::io::ImporterOBJ<CMeshO>::Info oi;
        oi.cb = cb;
        if (!vcg::tri::io::ImporterOBJ<CMeshO>::LoadMask(filename.c_str(), oi))
        {
            throw MLException(tr("Error while loading OBJ mask."));
        }

        if (oi.mask & vcg::tri::io::Mask::IOM_VERTTEXCOORD)
        {
            // textue data need to enable to alloc extra memory later
            cm.vert.EnableTexCoord();
        }

        int result = -1;
        try {
            result = vcg::tri::io::ImporterOBJ<CMeshO>::Open(cm, filename.c_str(), oi);
        }
        catch (std::exception& e) {
            qDebug() << __FUNCTION__ << __LINE__ << e.what();
            return false;
        }

        if (result != vcg::tri::io::ImporterOBJ<CMeshO>::E_NOERROR)
        {
            if (result & vcg::tri::io::ImporterOBJ<CMeshO>::E_NON_CRITICAL_ERROR)
            {
                qDebug() << errorMsgFormat.arg(fileName, vcg::tri::io::ImporterOBJ<CMeshO>::ErrorMsg(result));
            }
            else
            {
                throw MLException(errorMsgFormat.arg(fileName, vcg::tri::io::ImporterOBJ<CMeshO>::ErrorMsg(result)));
            }
            return false;
        }
    }

    else if ((formatName.toUpper()) == QString("STL") || (formatName.toUpper()) == QString("SUPPORT"))
    {
        int mask = 0;
        if (!vcg::tri::io::ImporterSTL<CMeshO>::LoadMask(filename.c_str(), mask))
        {
            throw MLException(errorMsgFormat.arg(fileName, vcg::tri::io::ImporterSTL<CMeshO>::ErrorMsg(vcg::tri::io::ImporterSTL<CMeshO>::E_MALFORMED)));
        }

        int result = -1;
        try {
            result = vcg::tri::io::ImporterSTL<CMeshO>::Open(cm, filename.c_str(), mask, cb);
        }
        catch (std::exception& e) {
            qDebug() << __FUNCTION__ << __LINE__ << e.what();
            return false;
        }
        if (result != 0) // all the importers return 0 on success

        {
            throw MLException(errorMsgFormat.arg(fileName, vcg::tri::io::ImporterSTL<CMeshO>::ErrorMsg(result)));
        }
    }
    return true;
}


void MeshModelImport_Export::save(const QString& formatName, const QString& fileName, CMeshO& cm, int mask, vcg::CallBackPos* cb)
{
    QString errorMsgFormat = "Error encountered while exportering file %1:\n%2";
    std::string filename = QFile::encodeName(fileName).constData();
    std::string ex = formatName.toUtf8().data();
    bool binaryFlag = false;
    if (formatName.toUpper() == QString("OBJ"))
    {
        //mask = vcg::tri::io::ExporterOBJ<CMeshO>::GetExportMaskCapability();// | vcg::tri::io::Mask::IOM_BITPOLYGONAL;
        mask = vcg::tri::io::Mask::IOM_VERTCOLOR;
        vcg::tri::Allocator<CMeshO>::CompactEveryVector(cm);
        //vcg::tri::io::Mask::ClampMask(cm, mask);
        int result;
        if (mask & vcg::tri::io::Mask::IOM_BITPOLYGONAL)
        {
            PMesh pm;
            vcg::tri::PolygonSupport<CMeshO, PMesh>::ImportFromTriMesh(pm, cm);
            result = vcg::tri::io::ExporterOBJ<PMesh>::Save(pm, filename.c_str(), mask, cb);
        }
        else
        {
            result = vcg::tri::io::ExporterOBJ<CMeshO>::Save(cm, filename.c_str(), mask, cb);
        }
        if (result != 0)
        {
            throw MLException(errorMsgFormat.arg(fileName, vcg::tri::io::ExporterOBJ<CMeshO>::ErrorMsg(result)));
        }
    }
    else if (formatName.toUpper() == QString("STL"))
    {
        mask  = vcg::tri::io::ExporterSTL<CMeshO>::GetExportMaskCapability();
        int result = vcg::tri::io::ExporterSTL<CMeshO>::Save(cm, filename.c_str(), true, mask, "STL generated by AnkerMake", false);
        if (result != 0)
        {
            throw MLException(errorMsgFormat.arg(fileName, vcg::tri::io::ExporterSTL<CMeshO>::ErrorMsg(result)));
        }
    }
}

void  MeshModelImport_Export::loadMesh(const QString& fileName, const std::list<CH3DPrintModelPtr>& printModelsList, std::list<int>& mask, vcg::CallBackPos* cb)
{

}
