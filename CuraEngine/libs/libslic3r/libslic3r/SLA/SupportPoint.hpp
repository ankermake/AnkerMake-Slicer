#ifndef SLA_SUPPORTPOINT_HPP
#define SLA_SUPPORTPOINT_HPP

#include <libslic3r/Point.hpp>

namespace Slic3r { namespace sla {

enum class PointsStatus {
    NoPoints,           // No points were generated so far.
    Generating,     // The autogeneration algorithm triggered, but not yet finished.
    AutoGenerated,  // Points were autogenerated (i.e. copied from the backend).
    UserModified    // User has done some edits.
};

struct SupportPoint
{
    Vec3f pos;
    Vec3f dir;
    float head_front_radius;
    int  icfType;
    SupportPoint()
        : pos(Vec3f::Zero()), head_front_radius(0.f), icfType(-1)
    {}
    
    SupportPoint(float pos_x,
                 float pos_y,
                 float pos_z,
                 float head_radius,
                 int  type = -1)
        : pos(pos_x, pos_y, pos_z)
        , head_front_radius(head_radius)
        , icfType(type)
    {}
    
    SupportPoint(Vec3f position, float head_radius, int type = -1)
        : pos(position)
        , head_front_radius(head_radius)
        , icfType(type)
    {}
    
    SupportPoint(Eigen::Matrix<float, 5, 1, Eigen::DontAlign> data)
        : pos(data(0), data(1), data(2))
        , head_front_radius(data(3))
        , icfType((int)data(4))
    {}
    
    bool operator==(const SupportPoint &sp) const
    {
        float rdiff = std::abs(head_front_radius - sp.head_front_radius);
        return (pos == sp.pos) && rdiff < float(EPSILON) &&
               icfType == sp.icfType;
    }
    
    bool operator!=(const SupportPoint &sp) const { return !(sp == (*this)); }
    
    template<class Archive> void serialize(Archive &ar)
    {
        ar(pos, head_front_radius, icfType);
    }
};

using SupportPoints = std::vector<SupportPoint>;

}} // namespace Slic3r::sla

#endif // SUPPORTPOINT_HPP
